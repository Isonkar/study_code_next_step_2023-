'''Морской бой - 2
«Морской бой» - игра для двух участников, в которой игроки по очереди называют координаты на неизвестной им карте соперника. Если у соперника по этим координатам имеется корабль, то корабль или его часть «топится», а попавший получает право сделать еще один ход. Цель игрока - первым поразить все корабли противника.

«Морской бой» очень популярен среди учеников одной физико-математической школы. Ребята очень любят в него играть на переменах. 
Вот и сейчас ученики Иннокентий и Емельян начали новую партию.

Правила, по которым ребята расставляют корабли перед началом партии, несколько отличаются от классических. 
Во-первых, игра происходит на поле размером N×M, а не 10×10. Во-вторых, число кораблей, их размер и форма выбираются ребятами перед партией - 
так играть намного интереснее.

Емельян уже расставил все свои корабли, кроме одного однопалубного. Такой корабль занимает ровно одну клетку.

Задана расстановка кораблей Емельяна. Найдите число способов поставить оставшийся однопалубный корабль. 
При этом учитывайте, что по правилам его можно ставить только в ту клетку, все соседние с которой не заняты. 
В этой задаче соседними считаются клетки, имеющие общую сторону.

Программа считывает два числа: N и M (1 ≤ N, M ≤ 100). Последующие N строк описывают игровое поле - каждая из них содержит M символов. 
Символом «.» (точка) обозначена свободная клетка, символом «*» (звездочка) - занятая кораблем.

Необходимо вывести на экран ответ на задачу

Разбор задачи 

Sample Input 1:
4 4
****
**..
*...
*...

Sample Output 1:
4

Sample Input 2:
4 3
***
...
...
***

Sample Output 2:
0


'''
#мой вариант (подсмотрел вариант как реализовать не выход из индекса)
n, m = map(int, input().split())
z = [list(''.join(input())) for _ in range(n)]

k = 0

for i in range(n):
    for j in range(m):
        if z[i][j] == '.':
            if z[i][j] == z[i][min(j + 1, m -1)]:
                if z[i][j] == z[i][max(j - 1, 0)]:
                    if z[i][j] == z[max(i - 1, 0)][j]:
                        if z[i][j] == z[min(i + 1, n - 1)][j]:
                            k += 1

            
print(k)

#вариант следующий

n, m = map(int, input().split())
z = [list(''.join(input())) for _ in range(n)]

k = 0

for i in range(n):
    for j in range(m):
        if z[i][j] == '.':
            if (i-1>-1 and z[i-1][j] == '*') \
            or (j-1>-1 and z[i][j-1] == '*') \
            or (j+1<m  and z[i][j+1] == '*') \
            or (i+1<n  and z[i+1][j] == '*'):
                continue
            else:
                k += 1
            
print(k)

#вариант два(увеличение матрицы для обхода без выхода за границы)

(n, m), cnt = map(int, input().split()), 0
s = ['.' * (m + 2)] + ['.' + input() + '.' for _ in range(n)] + ['.' * (m + 2)]
for i in range(1, n+1):
    for j in range(1, m+1):
        cnt += s[i][j] == s[i][j+1] == s[i][j-1] == s[i+1][j] == s[i-1][j] == '.' 
print(cnt)

# вариант три

n, m = (int(i) for i in input().split())                 # ввод строки/стобцы   
a = [[str(j) for j in input()] for i in range(n)]        # ввод поля боя
no_count = 0                                             # антисчетчик   
count = 0                                                # счетчик годных клеток 
for i in range(n):                                       # проход по строкам поля
    for j in range(m):                                   # в нем проход по столбцам
        if a[i][j] != '*':                               # если текущая клетка не корабль
            for d in (-1, 1):                            # то проход по соседям сверху-снизу + слева-справа
                ai = i + d                               # и расчет адресов соседей сверху-снизу
                if 0 <= ai < n and a[ai][j] == '*':      # и если сосед в рамках поля и это корабль
                        no_count += 1                    # тогда антисчетчик +1
                aj = j + d                               # и расчет адресов соседей слева-справа
                if 0 <= aj < m and a[i][aj] == '*':      # и если сосед в рамках поля и это корабль
                        no_count += 1                    # тогда антисчетчик +1
            count += 1 if no_count == 0 else 0           # если среди соседей нет кораблей то счетчик +1
            no_count = 0                                 # антисчетчик = 0 и обход поля до самого конца
print(count)

# вариант три оптимизированный
n, m = (int(i) for i in input().split())  # ввод строки/стобцы
a = [[str(j) for j in input()] for i in range(n)]  # ввод поля боя
count = 0  # счетчик годных клеток
for i in range(n):  # проход по строкам поля
    for j in range(m):  # в нем проход по столбцам
        if a[i][j] != '*':  # если текущая клетка не корабль
            for d in (-1, 1):  # то проход по соседям сверху-слева + снизу-справа
                ai = i + d  # адрес по строке сверху или снизу
                if 0 <= ai < n and a[ai][j] == '*':  # и если сосед в рамках поля и это корабль
                    break  # тогда завершаем цикл
                aj = j + d  # адрес по столбцу слева или справа
                if 0 <= aj < m and a[i][aj] == '*':  # и если адрес в рамках поля и это корабль
                    break  # тогда завершаем цикл
            else:
                count += 1  # если не было найдено кораблей по периметру счётчик +1
print(count)

# вариант четыре

n, m = map(int, input().split())
ls = [input() for i in range(n)]
count = 0
for i in range(n):
    for j in range(m):
        if ls[i][j] == ".":
            if ls[min(i+1,n-1)][j] == ls[max(i-1,0)][j] == ls[i][max(j-1,0)] == ls[i][min(j+1,m-1)] == ".":
                count += 1

print(count)
